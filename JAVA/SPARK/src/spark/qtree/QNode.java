//*********************************************************************************************************************
package spark.qtree;
//*********************************************************************************************************************

import java.util.List;

import org.eclipse.collections.impl.list.mutable.FastList;

//*********************************************************************************************************************
public class QNode {

	//=================================================================================================================
	private static final int
		XYZ = 0,
		xYZ = 1,
		XyZ = 2,
		xyZ = 3,
		XYz = 4,
		xYz = 5,
		Xyz = 6,
		xyz = 7,
		MAX_OBJECTS = 10;
	//=================================================================================================================
	
	//=================================================================================================================
	public double x, y, z, s;
	public QNode   parent;
	public QNode[] children;
	public List<QObject> objects = new FastList<QObject>();
	//=================================================================================================================
	
	//=================================================================================================================
	public QNode() {
		initBounds();
	}
	//=================================================================================================================

	//=================================================================================================================
	public QNode(QNode parent, int index) {
		this.parent = parent;
		initBounds(parent, index);
	}
	//=================================================================================================================

	//=================================================================================================================
	public void add(QObject o) {
		if (children == null) {
			o.node = this;
			objects.add(o);
			split();
		} else {
			boolean match = false;
			for (QNode c : children) {
				if (c.encloses(o)) {
					c.add(o);
					match = true;
					break;
				}
				if (!match) {
					o.node = this;
					objects.add(o);
				}
			}
		}
	}
	//=================================================================================================================

	//=================================================================================================================
	// soll durch eine HastTable QObject -> QNode in QTree unterstützt werden, um vor dem Löschen den richtigen QNode zu bestimmen.
	public void delete(QObject o) {
		if (objects.contains(o)) {
			objects.remove(o);
			join();
		}
	}
	//=================================================================================================================
	
	//=================================================================================================================
	private void initBounds() {
		x = 0.0;
		y = 0.0;
		z = 0.0;
		s = Double.MAX_VALUE;
	}
	//=================================================================================================================

	//=================================================================================================================
	private void initBounds(
			QNode parent,
			int index) {
		s = parent.s / 2.0;
		x = parent.x;
		y = parent.y;
		z = parent.z;
		switch (index) {
		case XYZ: x+=s; y+=s; z+=s; break;
		case xYZ: x-=s; y+=s; z+=s; break;
		case XyZ: x+=s; y-=s; z+=s; break;
		case xyZ: x-=s; y-=s; z+=s; break;
		case XYz: x+=s; y+=s; z-=s; break;
		case xYz: x-=s; y+=s; z-=s; break;
		case Xyz: x+=s; y-=s; z-=s; break;
		case xyz: x-=s; y-=s; z-=s; break;
		}
	}
	//=================================================================================================================

	//=================================================================================================================
	private void split() {
		if (children == null && sum() > MAX_OBJECTS) {
			children = new QNode[] {
				new QNode(this, XYZ),
				new QNode(this, xYZ),
				new QNode(this, XYZ),
				new QNode(this, xyZ),
				new QNode(this, Xyz),
				new QNode(this, xYz),
				new QNode(this, Xyz),
				new QNode(this, xyz)			
			};
			List<QObject> tmp = new FastList<QObject>(objects);
			for (QObject o : tmp) {
				for (QNode c : children) {
					if (c.encloses(o)) {
						objects.remove(o);
						o.node = c; 
						c.objects.add(o);
						break;
					}
				}
			}
		}
	}
	//=================================================================================================================

	//=================================================================================================================
	private void join() {
		if (children != null && sum() <= MAX_OBJECTS) {			
			children = null;
			accumulate(objects);
			for (QObject o : objects) {
				o.node = this;
			}
		}
	}
	//=================================================================================================================

	//=================================================================================================================
	private int sum() {
		int sum = objects.size();
		if (children != null) {
			for (QNode c : children) {
				sum += c.sum();
			}
		}
		return sum;
	}
	//=================================================================================================================

	//=================================================================================================================
	private void accumulate(List<QObject> list) {		
		if (objects != list) {
			list.addAll(objects);
		}
		for (QNode c : children) {
			c.accumulate(list);
		}
	}
	//=================================================================================================================
	
	//=================================================================================================================
	public boolean contains(double px, double py, double pz) {
		return
			(x-s) <= px && (x+s) >= px &&
			(y-s) <= py && (y+s) >= py &&
			(z-s) <= pz && (z+s) >= pz;
	}
	//=================================================================================================================

	//=================================================================================================================
	public boolean encloses(QObject o) {
		return
			(x-s) <= (o.x-o.sx) && (x+s) >= (o.x+o.sx) &&
			(y-s) <= (o.y-o.sy) && (y+s) >= (o.y+o.sy) &&
			(z-s) <= (o.z-o.sz) && (z+s) >= (o.z+o.sz);
	}
	//=================================================================================================================
	
	//=================================================================================================================
	public boolean encloses(double px, double py, double pz, double ps) {
		return
			(x-s) <= (px-ps) && (x+s) >= (px+ps) &&
			(y-s) <= (py-ps) && (y+s) >= (py+ps) &&
			(z-s) <= (pz-ps) && (z+s) >= (pz+ps);
	}
	//=================================================================================================================

	//=================================================================================================================
	public boolean intersects(double px, double py, double pz, double ps) {
		return
			(x-s) <= (px+ps) && (x+s) >= (px-ps) &&
			(y-s) <= (py+ps) && (y+s) >= (py-ps) &&
			(z-s) <= (pz+ps) && (z+s) >= (pz-ps);
	}
	//=================================================================================================================
	
}
//*********************************************************************************************************************
